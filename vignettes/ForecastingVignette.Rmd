---
title: "Adventures in forecasting: fitting climatological models using heteroscedastic GPs"
output: html_document
extra_dependencies: ["amssymb", "amsmath"]
bibliography: references.bib 
vignette: >
  %\VignetteIndexEntry{Adventures in forecasting: fitting climatological models using heteroscedastic GPs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(hetGP4cast)
```

In this vignette, we will construct climatological forecasts using a heteroscedastic Gaussian process (GP). "Heteroscedastic" means the noise associated with a response variable depends on the inputs (covariates). Lake temperatures exhibit heteroscedasticity over the time of year and depth of the lake, and it it important to incorporate this when performing uncertainty quantification (UQ) for a forecast. Heteroscedastic GPs are advantageous, as they can account for input dependent noise, make accurate predictions, and provide adequate smoothing. 

Several techniques exist for modeling input-dependent noise in GPs, but the most efficient methods leverage replication. In the approach by @goldberg1997regression the mean and variance are modeled separately, and MCMC sampling is employed for parameter estimation. @quadrianto2009kernel proposed a heteroscedastic quantile regression technique using a GP prior, while @lazaro2011variational developed a variational inference technique for fitting GPs with input-dependent noise. However, these methods come with high computational demands. Stochastic kriging @ankenman2008stochastic is a simple, in which mean and variance are modeled separately with two GPs. However, the number of replicates must be large (>10), and its method of moments-based inferential framework can cause a loss in coherency @gramacy2020surrogates. The heteroscedastic GP developed by @binois2021hetgp (hetGP) leverages replication for gains in efficiency and weights the variance over input locations based on the number of replicates. It is more flexible than stochastic kriging in that the number of replicates over unique input locations need not be large. The `hetGP4cast` package is a wrapper for the `hetGP` package @binois2021hetgp, and we refer the interested reader to @binois2021hetgp and @gramacy2020surrogates for full details.

## Constructing climatological forecasts
### DOY-only models

In this section, we will use the `hetGP4cast` package to fit hetGP's to sample data and construct climatological forecasts for a desired reference date. 

The `hetGP4cast` package is simple and includes only 2 main functions: `fit_hetgp()` and `predict_hetgp()` for fitting hetGPs and predicting (forecasting) using the fitted model. The parameters for `fit_hetgp()` are:


* `X:` model inputs (covariates). Can be either `DOY` or `c(DOY, depth)`. `DOY` refers to using Julian day of year as a covariate, and `depth` refers to using lake depth as a covariate. No other values will work.
* `Y:` response variable. Must be one of the unique values of the `variable` column in `df`.
* `site_id`: The focal site. Must be one or more of the unique values of the `site_id` columns of `df`.
* `df` the input dataframe. Must be in standard format, see [here](https://projects.ecoforecast.org/tern4cast/instructions.html#target-data-calculation). The only other extra column that may be included must have a column name `depth` and should denote the depth of the temperature in m. The `datetime` column must be formatted as YYYY-MM-DD, but it may either be of class `string, POSIXct` or `Date`.
* `covtype`: the type of covariance function used in fitting the hetGP. We recommend `Gaussian` (the default), but any one of `Gaussian`, `Matern3_2` or `Matern5_2` are acceptable. 
* `silent`: if `TRUE` additional output will be printed to the console.

`fit_hetgp()` will not work if `df` is not of standard format (has extra or missing columns or if column classes are incorrect). However, it will return informative errors telling the user what the issue is.

Let's fit a simple hetGP to lake temperatures using only Julian day of year (DOY) as the covariate. Such a model would be most sensible if we are only interested in modeling one depth (so `depth` should not appear as a column in `df`). Additionally, we strongly recommend transforming any censored responses (chlorophyll) before model fitting (log or square root transforms are recommended).

First, we open an example dataset. 
This sample dataset contains only lake temperatures for several reservoirs.
```{r}
# read data
lakedat=readr::read_csv("https://data.ecoforecast.org/neon4cast-targets/aquatics/aquatics-expanded-observations.csv.gz", show_col_types = FALSE)

# extract only 00UTC
lakedat$hour = format(lakedat$datetime, format = "%H:%M:%S")

lakedat = lakedat[lakedat$hour == "00:00:00", ]
lakedat$hour = NULL

# extract only 1m depth observations; get rid of depth column; eliminate NAs
lakedat = lakedat[complete.cases(lakedat), ]
lakedat1 = lakedat[lakedat$depth == 1, ]
lakedat1$depth = NULL

# inspect resulting df
head(lakedat1)
```

Let's fit a day of year climatological model for the `SUGG` site.
```{r}
model1 = fit_hetgp(X = "DOY", Y = "temperature",
                   site_id = "SUGG", df = lakedat1)
```


`fit_hetgp()` returns a list with the following items:
* hetGP fit object containing information about the model fit
* `df`: the input dataframe 
* `include_depth`: boolean to denote whether or not depth was used as a covariate
* `Yname`: values of the response variable

To make forecasts, we need only to pass the return value of `fit_hetgp()` to `predict_hetgp()`. `predict_hetgp()`'s parameters include:
* `hetGP_fit:` hetGP object fit from `fit_hetgp()`
* `save_covmat:` boolean, denotes whether the predictive covariance matrix should be saved (default is \texttt{FALSE})
* `reference_datetime`: the reference date for which forecasts are desired. `reference_datetime` can be either a string or of class `Date` or `POSIXct` and must be formatted as `YYYY-MM-DD`.
* `max_horizon`: the maximum forecast horizon in days (default is 35).
* `depths`: Depths (m) for which forecasts are desired (if applicable, this option is ignored if depth is not a covariate). If `depth` was used as a covariate in the object produced from `fit_hetgp()`, the user may specify which depths to include in a forecast. Only numerical values greater than 0 are allowed for `depths` (default is `1:10`).
* `PI`: value in [0,1) to denote value of prediction intervals. We recommend `PI` = 0.90 or 0.95 (default is 0.90).

```{r}
preds1 = predict_hetgp(het_gp_object = model1, reference_datetime = "2023-09-01")
```

`predict_hetgp()` returns a list containing the following items:

* `pred_df`: a `data.frame` in standard format containing `max-horizon`-day ahead forecasts for the desired `reference_datetime`
* `covmat`: the predictive covariance matrix (if `save_covmat` = TRUE; otherwise `covmat` will be `NULL`. Note that the nugget term is included on the diagonal of `covmat`.
* `df` the original input `data.frame` for `fit_hetgp()`
* `preds4plotting`: a `data.frame` formatted for easy plotting; includes columns `Mean` (predictive mean), `sd` (standard deviation), `DOY`, `Lower` and `Upper` (lower and upper bounds for prediction intervals).
* `include_depth`: boolean to denote whether or not `depth` was a model input
* `Yname`: name of the response variable `Y`
* `pred_width`: width of prediction intervals (value in `[0,1)`)


Now, we can quickly plot the forecast and prediction intervals using `plot`. (Custom plots can also be created--see Creating Custom Plots). Notice both the predicted mean (forecast) and the prediction intervals are smooth.
```{r, fig.dim=c(6,6)}
plot_hetGPpreds(predObject = preds1)
```

What do we gain by fitting a GP rather than naively calculating means and sd's? Let's try it.
```{r}
temp = lakedat1[lakedat1$site_id == "SUGG", ]
temp$DOY = as.integer(format(temp$datetime, "%j"))
# for dplyr, use: avesdf = temp %>% group_by(DOY) %>%
# summarize(Mean = mean(observation), SD = sd(observation))
avesdf = aggregate(observation ~ DOY, data = temp, 
          FUN = function(x){
            Mean=mean(x, na.rm = TRUE)
            SD = sd(x)
            return(c(Mean, SD))
            }
          )

avesdf <- do.call("data.frame", avesdf)
colnames(avesdf) = c("DOY", "Mean", "SD")
avesdf = avesdf[avesdf$DOY %in% 245:280, ]
# get 90% 'prediction' intervals
avesdf$Upper = avesdf$Mean + 1.645*avesdf$SD 
avesdf$Lower = avesdf$Mean - 1.645*avesdf$SD 
```

```{r, fig.dim=c(6,6)}
# make plot
plot(avesdf$DOY, avesdf$Mean, type = "l",
     ylab = "Mean", ylim = c(22, 35))
lines(avesdf$DOY, avesdf$Upper, lty = 2)
lines(avesdf$DOY, avesdf$Lower, lty = 2)
legend("topright", legend = c("Mean", "90% pred intervals"),
       lwd=2, lty = c(1,2))
```
Clearly, smoothness is an issue, and uncertainty is not robustly quantified, as all SDs are weighted equally, regardless of the number of replicates for each DOY. By definition, climatological forecasts focus on broader trends and tendencies over longer time periods, so we would expect some degree of smoothness for both the mean and prediction intervals of a climatological forecast. The fitting mechanism for a hetGP accounts for unequal number of replicates over unique inputs (either DOY or DOY and depth) and provides smooth means and prediction intervals.


Now let's try making a forecast using a hetGP climatological model and and empirical model. We'll split the dataset for the `SUGG` site into training and testing sets, fit competing models to the train set, and compare forecasts to observations in the test set.
```{r}
# train on 2017-2022
laketrain = lakedat1[lakedat1$datetime <= as.Date("2022-01-01"), ]

# test on 2022
laketest = lakedat1[lakedat1$datetime > as.Date("2022-01-01"), ]

# HetGP training model 
modeltrain = fit_hetgp(X = "DOY", Y = "temperature",
                   site_id = "SUGG", df = laketrain)

# obtain predictions
trainpreds = predict_hetgp(het_gp_object = model1, reference_datetime = "2023-09-01")

# obtain empirical means/SDs on the training set for the SUGG site
temp = laketrain[laketrain$site_id == "SUGG", ]
temp$DOY = as.integer(format(temp$datetime, "%j"))
# for dplyr, use: avesdf = temp %>% group_by(DOY) %>%
# summarize(Mean = mean(observation), SD = sd(observation))
avesdf = aggregate(observation ~ DOY, data = temp, 
                   FUN = function(x){
                     Mean=mean(x, na.rm = TRUE)
                     SD = sd(x)
                     return(c(Mean, SD))
                   }
)

avesdf <- do.call("data.frame", avesdf)
colnames(avesdf) = c("DOY", "Mean", "SD")
avesdf = avesdf[avesdf$DOY %in% 245:280, ]
# get 90% prediction intervals
avesdf$Upper = avesdf$Mean + 1.645*avesdf$SD 
avesdf$Lower = avesdf$Mean - 1.645*avesdf$SD 
```

```{r, fig.dim=c(8,6)}
# extract data for the SUGG site from test set
sugtest = laketest[laketest$site_id == "SUGG", ]
sugtest$DOY = as.integer(format(sugtest$datetime, "%j"))
sugtest = sugtest[sugtest$DOY %in% 245:280, ]

# these are the forecasts from the hetGP model
hetpreds = trainpreds$preds4plotting

# make a plot
plot(hetpreds$DOY, hetpreds$Mean, type = "l",
     lwd = 2, ylim = c(23, 32), ylab = "Temp C", xlab = "DOY",
     col = "darkorange")
lines(hetpreds$DOY, hetpreds$Lower, lwd = 2, lty = 2, col = "darkorange")
lines(hetpreds$DOY, hetpreds$Upper, lwd = 2, lty = 2, col = "darkorange")
lines(avesdf$DOY, avesdf$Mean, lwd = 2, col = "darkgray")
lines(avesdf$DOY, avesdf$Upper, lty = 2, lwd = 2, col = "darkgray")
lines(avesdf$DOY, avesdf$Lower, lty = 2, lwd= 2, col = "darkgray")
points(sugtest$DOY, sugtest$observation, col = "purple", pch = 19)
legend("bottomleft", legend = c("hetGP", "Empirical",
                                "test observations"), lwd=2, 
       lty=1, col = c("darkorange", "darkgray", "purple"))
```

The empirical as well as hetGP climatological models both do reasonably well with respect to prediction and prediction interval coverage.  

### Depth and DOY models
Let's fit a model that also includes depth. To keep computation time down, we only use depths 1 and 2 for this example. If there are not enough replicates over `depth` and `DOY`, parameter estimation is not possible, and will get an error (you can check the number of replicates by doing `table(df$depth, df$DOY)` after converting the `datetime` column to DOY (Julian day).:


We can proceed exactly as before, but this time we include `depth` as a covariate. Note that including `depth` may result in a substantially longer computation time. We do not recommend fitting models to datasets of more than 5,000 observations. When the input `df` contains the extra column `depth`, the user may elect to only use only `DOY` as the covariate. However, we do not recommend doing so, as the model will pool observations from all depths.

```{r cache=FALSE}
# extract only depths 1 and 2
lakedat2 = lakedat[lakedat$depth %in% 1:2, ]
# takes a little bit to run
model_depth = fit_hetgp(X = c("DOY","depth"), Y = "temperature",
                   site_id = "BARC", df = lakedat2)
```


We can use the `predict_hetgp()` function as before, but we specify `depths` to be `1:2`.
```{r}
modeld_preds = predict_hetgp(het_gp_object = model_depth, reference_datetime = "2023-09-01", depths = 1:2)
```

As before, the results can be plotted using `plot()`.
```{r, fig.dim=c(8,6)}
plot_hetGPpreds(predObject = modeld_preds)
```

## Creating custom plots
We can quickly plot results by passing the object from `predict_hetgp()` to `plot`. However, users may also create custom plots. The `preds4plotting` `data.frame` can be used for plotting. Let's use the predictions from the DOY-only model fit.

```{r}
preds4plotting = preds1$preds4plotting
head(preds4plotting)
```


```{r, fig.dim=c(6,6)}
library(ggplot2)
ggplot(data = preds1$preds4plotting, aes(x = DOY, y = Mean, col = "Mean")) +
  geom_line(linewidth = 1) +
  geom_line(aes(x = DOY, y = Upper, col = "PI"), linetype = "dashed", linewidth = 1) +
  geom_line(aes(x = DOY, y = Lower, col = "PI"), linetype = "dashed", linewidth = 1) +
  theme_bw() +
  ylab("Temperature") +
  scale_color_manual(breaks = c("Mean", "PI"), 
                     values = c(Mean = "#503A9B",
                                PI = "#503A9B"),
                     labels = c("Mean",  "90% PI"),  
                     guide = guide_legend(override.aes = list(
                       linetype = c("solid", "dashed"))),
                     name="") +
  theme(legend.position = c(0.11, 0.16), legend.text=element_text(size=14),
        legend.background=element_rect(fill = alpha("white", 0.1)))
```

## Advanced 

To construct realizations from the posterior predictive distribution, only the predictive mean and covariance matrix are necessary. Suppose we have some data $D$ composed of $(x,y)$ pairs, and we are interested in determining which function $f(x)$ generated the data $D$. If we assign a GP prior to $f$, we have $f \sim GP$. Given this setup, the posterior distribution $f(x)|D$ is generally of interest. Since we are usually interested in predictions at new values of $x$, $x*$, we usually want the posterior predictive distribution. Fortunately the posterior predictive distribution is also multivariate normal. That is, for several new $x$ locations $\mathcal{X}$ we are interested in $Y(\mathcal{X}) \mid D$: $Y(\mathcal{X}) \mid D \sim \mathcal{N}(\mu(\mathcal{X}), \Sigma(\mathcal{X}))$. Both $\mu(\mathcal{X})$ and $\Sigma(\mathcal{X})$ can be obtained from `predict_hetgp()`.

```{r}
preds2 = predict_hetgp(het_gp_object = model1, reference_datetime = "2023-09-01",
                       save_covmat = TRUE)
dim(preds2$covmat)
```

Now, to generate realizations, we can use the following function (alternatively, one could use the `mvtnorm` package.)
```{r}
# function to generate MVN realizations
rmultnorm <- function(n, mu, sigma){
  p <- length(mu)
  z <- matrix(rnorm(n * p),nrow=n)
  svdsig <- svd(sigma)
  ch <- sqrt(diag(svdsig$d)) %*% t(svdsig$u)  
  zz <- z %*% ch
  zz + matrix(mu,nrow=n,ncol=p,byrow=T)
}
```

The function `rmultnorm()` takes in `n`, the number of realizations, `mu`, a mean vector, and `sigma` a covariance matrix. 

```{r, fig.dim=c(8,6)}
mu = preds2$preds4plotting$Mean
length(mu)
sigma = preds2$covmat
dim(sigma)
nreals = 200
# note: smoother means and 90% PIs can be achieved with more realizations
reals = rmultnorm(n = nreals, mu = mu, sigma = sigma)
matplot(245:279, t(reals), type= "l", col = "gray", xlab = "DOY")
```

We can then extract means, 95th and 5th quantiles and make a plot.
```{r, fig.dim=c(8,6)}
mymean = apply(reals, 2, mean)
Qupper = apply(reals, 2, function(x) quantile(x, probs = .95))
QLower = apply(reals, 2, function(x) quantile(x, probs = .05))

matplot(245:279, t(reals), type= "l", col = "gray",
        ylab = "Mean", xlab = "DOY", ylim = c(20, 34))
lines(245:279,mymean, type = "l")
lines(245:279,Qupper, lty=2)
lines(245:279,QLower, lty=2)
legend("topright", legend = c("Mean", "90% PI"), lty = c(1,2))
```



Fortunately, the `hetGP4cast` package includes a function to generate realizations. We need only to pass the prediction object to the function `make_realizations`. The number of realizations desired is specified with `nreals`.
```{r}
mySims = make_realizations(predObject = preds2, nreals = 500)
```

The function returns a list containing a data.frame in standard format including the realizations as well as a matrix containing the realizations.

```{r}
head(mySims$pred_df_reals)
```

